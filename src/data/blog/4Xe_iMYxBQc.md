---
author: AI Makers Club
pubDatetime: 2025-07-27T08:18:44.990Z
title: "Information Retrieval from the Ground Up - Philipp Krenn, Elastic"
slug: 4Xe_iMYxBQc
featured: true
draft: false
tags:
  - AI
  - YouTube 요약
  - 자동 업로드
description: "이 영상은 Elastic 소속 Philipp Krenn이 정보 검색(information retrieval)의 원리와 발전, 그리고 벡터 검색 및 하이브리드 검색까지 최신 검색 기"
---

<div style="text-align: center;">
  <img src="https://img.youtube.com/vi/4Xe_iMYxBQc/maxresdefault.jpg" alt="YouTube Thumbnail" style="width: 100%; max-width: 640px; height: auto; border-radius: 0.5rem; box-shadow: 0 2px 8px rgba(0,0,0,0.1);" loading="lazy" />
</div>

**영상 링크:** [Information Retrieval from the Ground Up - Philipp Krenn, Elastic](https://www.youtube.com/watch?v=4Xe_iMYxBQc)  
**채널명:** AI Engineer

## *기초부터 시작하는 정보 검색 - Elastic의 Philipp Krenn* 핵심 요약

- 이 영상은 Elastic 소속 Philipp Krenn이 정보 검색(information retrieval)의 원리와 발전, 그리고 벡터 검색 및 하이브리드 검색까지 최신 검색 기술을 실습 위주로 심도 있게 설명한 세미나임
- 발표자는 RAG(Retrieval Augmented Generation)에서 "R(검색)"에 집중하여, 텍스트에서 원하는 정보를 어떻게 빠르고 정확하게 검색할 수 있는지 다양한 전략을 공유함
- 검색의 역사는 50~70년으로 거슬러 올라가며, 키워드(lexical) 검색과 벡터(vector) 검색, 하이브리드(hybrid) 검색 등 여러 기술의 비교 시연이 이루어짐
- ElasticSearch를 활용한 실제 데모에서, 검색 엔진이 데이터를 저장할 때 데이터베이스와 달리 미리 토크나이즈(tokenize), 오프셋 저장, 포지션 저장, 어간 추출(stemming), 소문자화 등 다양한 전처리를 적용하여 검색 효율을 높인다는 점을 강조함
- 다양한 언어 분석(ex. 영어, 독일어, 프랑스어) 시 언어별 불용어(stop word), 어간 추출 규칙의 중요성과 부적절한 언어 적용 시 발생하는 문제점 설명
- 데이터를 실제로 색인하고, 다양한 쿼리(단어, 구, 동의어, 오탈자 포함)와 그 처리 방식(예: ngram)을 단계별로 보여줌
- 검색 결과의 점수화 방식으로 TF-IDF와 BM25의 원리와 산식, 그리고 점수가 절대적 기준(예: 100%)이 될 수 없는 이유를 구체적으로 설명함
- 키워드 검색의 한계(동의어 및 의미 불일치, 복합어 처리, 오탈자 대응 등)에 대한 논의와, 이를 개선하기 위한 벡터 검색, 스파스벡터(sparse vector), 딥러닝 임베딩(embedding) 기반의 의미 검색 기법을 소개함
- 쿼리 확대(query expansion), 하이브리드 검색, RRF(Reciprocal Rank Fusion) 등 다수의 검색 기법 및 실제 적용 시 고려사항(여러 쿼리 방식의 조합, 점수 정규화, 필터/랭킹 피쳐 등)에 대해 설명
- ElasticSearch 내에서 실용적인 검색 구축 및 성능 개선 방법, 최신 기능(API 기반 파이프 쿼리 언어, 리랭킹 등)까지 폭넓게 다룸

---

## 세부 요약 - 주제별 정리

### RAG에서 "R(검색)"에 집중하여 검색 기술의 근본을 탐구함

- 발표자는 RAG(검색 기반 생성) 중 "검색" 파트만 집중적으로 설명하겠다고 밝히며, 생성은 다루지 않음을 안내
- 검색의 본질: 생성(G) 이전에 적절한 정보(문맥, context)를 효과적으로 찾아주는 과정이 핵심임을 강조
- RAG 및 벡터 검색 경험, 키워드 검색 경험 등을 청중과 확인하며, 다양한 검색 방법이 존재한다는 점을 환기함
- 검색의 역사는 50~70년 정도로, 매우 오랜 기간 축적된 기술이라는 점을 언급

### 검색의 기본 원리: 토크나이즈, 전처리, 오프셋·포지션 저장의 목적과 데이터베이스와의 차이

- 클랙식(키워드/렉시컬) 검색은 텍스트를 단어 단위로 분해(토크나이즈)하여 개별 단어로 색인(token 생성)함
- 저장 시 각 토큰의 시작/끝 오프셋(offset), 포지션(position) 정보도 저장; 하이라이트, 구문 검색 등 활용 가능
- 검색엔진은 데이터베이스와 달리, 입력 시(색인 시) 전처리를 집중 수행해 저장 구조를 최적화하고, 쿼리(검색) 시 더 빠른 결과 제공
- 예시: "These are not the droids you’re looking for"에서 토크나이즈 결과(오프셋, 포지션), 불용어 제거, 어간 추출 등이 어떻게 이뤄지는지 실습
- 영어 외 독일어, 프랑스어 등 다양한 언어별 분석기의 차이와, 언어가 잘못 지정될 경우 잘못된 결과(예: 어처구니없는 어간 추출 등) 발생 사례 설명

### 불용어(stop word) 및 텍스트 전처리의 중요성과 예외 상황

- 불용어는 주로 검색 가치를 낮추는, 매우 빈번하게 등장하는 단어들을 지정하여, 검색 인덱스와 결과의 효율화를 도모함
- 각 언어마다 다른 불용어 목록이 정교하게 정의되어 있음(예: 영어 약 33개)
- 불용어 제거는 기본이지만, "to be or not to be"처럼 중요한 어구의 경우 모든 단어가 불용어라 역효과 발생 가능성 있음
- 항상 불용어를 제거해야 하는가에 대한 논의 → "상황에 따라 다르다(it depends)", 사용자 요구와 특성에 따라 커스터마이징 필요

### 색인(mapping) 생성 및 실제 데이터 저장 예시, 토크나이저/분석기 커스터마이징

- ElasticSearch의 mapping(스키마 유사)을 정의하여 필드 별로 분석기(불용어 제거, 토크나이저 종류, 어간 추출 등)를 커스터마이징 가능
- 실제로 인덱스를 생성하고, "These are not the droids you’re looking for", "No, I am your father", "Obi-Wan never told you..." 등 다양한 스타워즈 대사를 예시로 넣어 토큰화, 불용어 처리, 토크나이저 차이에 따른 결과 확인
- 토크나이저 종류의 차이(standard vs whitespace 등)와 복합어, 이메일, URL 등 특별한 데이터에 적합한 전처리 필요성 설명

### 인버티드 인덱스(inverted index)라는 자료구조의 원리와 검색의 효율성 확보

- DB는 저장 후 쿼리 시 연산이 많으나, 검색엔진은 저장 시 토큰을 미리 추출·정렬하여 문서와의 매핑 정보로 인버티드 인덱스를 생성함
- 인버티드 인덱스: 토큰을 알파벳 순으로 정렬, 각 토큰이 등장하는 문서 ID와 포지션 저장
- 예시: "droid"로 검색할 때 복수/단수, 대소문자 무관하게 동일한 결과가 나오는 이유 설명(어간 추출, 소문자화 등이 동작)
- 빠르고 효율적인 근거로 인버티드 인덱스의 작동 원리를 상세히 소개

### 키워드 검색의 한계: 동의어, 복합어, 오탈자(fuzziness), ngram, 언어별 특성과 도구 활용

- 동의어(synonym) 처리는 일일이 매핑하거나, 요즘은 LLM 활용 동의어 자동 생성 가능
- 동음이의어(homonym)·다의어 대응의 한계: 맥락 인식이 불가, 단순 문자열 매칭임
- 예시: blackberry(블랙베리), 복합어 분리/검색의 한계, 한국어/독일어처럼 복합어가 많은 언어의 특수성 및 engram(부분 단위로 분할) 처리 도입, 단점(저장 공간, 처리 비용, 여파 등) 설명
- 오탈자 검색(fuzziness): Levenshtein 거리 기반 오차 허용(몇 자까지 허용 등), 토크나이저 별 단어 단위 적용됨을 예시로 시연
- ngram(2-gram, 3-gram, edge ngram 등): 복합어 검색 보조, 저장·검색 비용이 증가하는 trade-off 구체 설명
- 다국어 데이터 검색 시 필드를 분리하고 언어별 분석기를 각각 지정하는 방안 안내, 언어 감지 자동화 기능도 소개

### TF-IDF, BM25 기반 점수 산정 원리와 점수의 상대성·한계

- TF(용어 빈도): 검색어가 문서 내 얼마나 반복되는지(예: 1번, 10번), BM25는 5회 이상부터 가중치 증가 폐곡선
- IDF(역문서 빈도): 전체 문서 중 해당 용어가 얼마나 희귀한지, 희귀할수록 가중치↑, 흔할수록↓
- 길이 정규화: 문서가 짧을수록 동일 용어 등장 시 더 높은 점수
- 점수 산정의 전 과정 수식과 예시, explain 명령어로 실제 점수 산식과 결과를 상세히 설명
- 검색 점수는 쿼리별 정렬에만 의미가 있고, 절대값이나 백분율(100% 대비 60% 등)로 해석하면 안 되는 이유, 문서 추가·삭제에 따라 점수의 변동성을 실례로 설명

### 심화 검색: 구(search phrase), 슬롭(slop), 오탈자, 리랭킹 등 고급 기능과 한계

- 구문 검색: 단어의 연속적 등장 필요, 불용어 제거와 포지션 정보 활용, 복수 단어의 위치 불일치(슬롭: 단어 사이 허용 범위 지정) 처리 방식 설명
- 리랭킹(rescoring): 대규모 문서에서 1차 가볍게 추린 뒤, 상위 n개만 비용 높은 심층 리랭킹 적용해 효율 추구(예: 최근 Elastic에 내장된 rerank 모델·API 설명)
- 점수 조작: 매출 마진, 사용량, 평점 등 외부 랭킹 피쳐와 혼합, 커스텀 점수 구현 방법
- 검색 결과 점수 조정, 블렌딩(가중치, 정규화), RRF(Reciprocal Rank Fusion, 각 방법의 랭킹을 조합해 결과 조율) 등의 기법 설명

### 의미 기반 검색의 도입: 임베딩 기반 벡터 검색, 스파스/덴스 벡터, 모델 특성 및 동작 원리

- Dense Vector: 문장 전체를 수백~수천 차원 벡터로 임베딩, 코사인 유사도 등으로 벡터 간 거리 계산해 의미가 비슷한 문서를 검색
- Sparse Vector: TF/IDF와 비슷하지만, 딥러닝에서 학습된 토큰과 가중치 집합을 사용(예: SPLADE 모델), 해석이 상대적으로 용이하나 검색시 비용과 토큰 수 증가
- OpenAI text embedding 등의 구체적 임베딩 API, 128 차원 소/대규모 모델 설명(차원이 늘면 비용·정확도 trade-off)
- 임베딩 벡터를 실제로 저장/확인, dense/sparse 두 방식 모두 실습
- Dense 방식의 경우 모든 쿼리에 대해 항상 어느 정도 유사(불일치 마저도)한 결과가 반환되어, 키워드 기반(정합 불일치=무응답)과 차이 있음 유념 필요
- 벡터 기반 검색 결과의 점수 해석, 임계값 설정(Threshold)의 어려움, 실제 대규모 데이터에서는 상위 n개 노출에 그런 문제가 덜한 경우가 많음을 설명

### 벡터 검색과 하이브리드 검색의 조합, 그리고 랭킹 전략의 실제 적용 및 트레이드오프

- 실제 서비스환경에서는 하이브리드 검색(키워드 & 벡터)의 중요성 강조; 각각의 장단점 보완 필요(브랜드명 검색 등 키워드가 강한 케이스, 의미 유추가 유리한 케이스의 구분)
- 하이브리드 검색 적용 시 결과 score normalization, RF 등 다양한 점수 혼합 전략, 각 쿼리 방식의 장단점을 실사례와 함께 비교
- 필터(Boolean Filter), 랭킹 피쳐(상품 마진, 평점, 재고 등)의 함께 적용 구조 안내
- 실제 ElasticSearch에서 각각의 검색 결과 창(window) 설정, cut-off(최소 점수) 지정, 한 쿼리 내 여러 색인·검색 방법 조합 예시 제시

### Chunking(텍스트 분할)과 대규모 문서/분산 환경에서의 검색 처리 전략

- 긴 문서(예: 책 전체, 대화 로그 등)는 페이지·단락·문장 등으로 분할(chunking)하여 각 조각을 임베딩 및 검색 효율성을 확보
- Overlapping(겹치는) 분할 등 다양한 분할 전략 설명, 치환·되찾기(Highlight) 구현 예시 시연

### 최신 ElasticSearch 기능: 파이프(pipe) 기반 쿼리 언어, API 사용, 다중 검색 방법 지원

- JSON 쿼리의 복잡함 완화를 위해 파이프 기반(쉘 스타일) 쿼리 문법 소개: 간단한 문법으로 기본·벡터·하이브리드 검색 가능
- 조인(join), 리랭킹, 다양한 데이터 필터링, 통계적 집계 등 다양한 검색 연산의 확장성 부각
- 현재는 클라이언트 언어(Java 등) 연동·Strong-typing은 미흡하나, 향후 발전 예정 안내

### 실제 운영 및 데이터 적재 관리: 문서 고유 ID, 중복 방지, ElasticSearch 내부 구조 및 성능 논의

- 대용량 데이터셋에서 파일 단위 해시값을 문서 ID로 활용하여 중복 적재 방지 및 인덱스 효율화 방법 제시
- HNSW(하이브리드 인덱스) 구조의 업그레이드 및 성능 최적화 방안(버전별 최적화, 세그먼트 병합 등) 상세 설명
- 업그레이드, 리랭킹 등 최신 기능 활용 방법 및 ElasticSearch 최신 버전별 성능 차이 안내

### 검색 품질 평가 및 검색 서비스 튜닝의 실무적 함의

- "좋은 검색"의 정의와 품질 평가는 전통적으로 골든 데이터셋/클릭스트림/사용자 행동 분석/LLM 활용 등 여러 계량적·정성적 지표 병행
- 활용 목적(예: 이커머스 vs 법률 DB)에 따라 적용 전략이 완전히 달라지므로, 도메인 특성에 맞춘 설계와 튜닝 필요성 강조
- 사용자가 주로 단일 단어 검색을 하는지 복합 쿼리를 쓰는지 등 실제 쿼리 패턴에 따라 적합한 검색전략(키워드/벡터/하이브리드) 선택 권장

### Q&A로 마무리하며, Elastic 최신 기능 및 추가 자료 안내

- 다양한 실시간 Q&A를 통해 실제 운영 사례, 벡터 차원 수에 따른 trade-off, 리랭킹 API 등 추가 정보 제공
- Elastic 부스·스티커 안내 및 실습 인스턴스 일정 개방 안내로 마무리

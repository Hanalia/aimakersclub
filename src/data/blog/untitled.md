---
author: AI Makers Club
pubDatetime: 2026-01-16T08:19:07.094Z
title: "Stacked Diffs Changed How I Reviewed Code with AI"
slug: untitled
featured: true
draft: false
tags:
  - AI
  - YouTube 요약
  - 자동 업로드
description: "영상에서는 AI를 활용한 코드 리뷰의 강력함과, 효과를 극대화하는 워크플로우로 '스택 디프(차등 누적 변경, stacked diffs)' 방식을 소개함 전통적인 풀 리퀘스트(Pul"
---

<div style="text-align: center;">
  <img src="https://img.youtube.com/vi/untitled/maxresdefault.jpg" alt="YouTube Thumbnail" style="width: 100%; max-width: 640px; height: auto; border-radius: 0.5rem; box-shadow: 0 2px 8px rgba(0,0,0,0.1);" loading="lazy" />
</div>

**영상 링크:** [Stacked Diffs Changed How I Reviewed Code with AI](https://www.youtube.com/shorts/IRWjtlpNUCU)  
**채널명:** Cole Medin

## *스택 디프(차등 누적 변경) 방식을 통해 AI 코드 리뷰가 혁신적으로 향상됨* 핵심 요약

- 영상에서는 AI를 활용한 코드 리뷰의 강력함과, 효과를 극대화하는 워크플로우로 '스택 디프(차등 누적 변경, stacked diffs)' 방식을 소개함
- 전통적인 풀 리퀘스트(Pull Request) 방식에서는 코드 변경 승인과 반복적 작업 대기가 필수적이나, 스택 디프는 작은 변화 단위(디프)들을 순차적으로 서로 위에 쌓으며 작업함
- 스택 디프 덕분에 각 변경 단위 사이에서 승인 대기 없이 이어지는 작업이 가능하며, 각 코드 변경에 대해 집중적이고 세분화된 AI 피드백을 받을 수 있음
- 그래파이트(Graphite)라는 플랫폼이 스택 디프 작업을 매우 쉽게 만들어주며, GitHub CLI와 유사한 명령어 도구와 대시보드, AI 코드 어시스턴트가 내장됨
- 그래파이트의 회원가입 후 제공되는 데모 안내가 직관적으로 첫 스택 디프 생성부터 단계별 수행 방법을 안내함
- 실제로 첫 번째 변경을 생성, 풀 리퀘스트(Pull Request)를 등록하고, 이후 연속적으로 서로 위에 쌓는 추가 풀 리퀘스트를 만드는 과정이 시연됨
- 대시보드에서 각각의 풀 리퀘스트 관리, AI를 통한 개별 리뷰, 머지(Merge)가 모두 가능하며, GitHub 레포지토리 접근 없어도 작업 가능함
- 각 변경점이 별도의 피처 브랜치에 위치해 순차적으로 병합되고, 최종적으로 메인(Main) 브랜치에 반영하는 전체 구조가 구체적으로 설명됨
- Claude 코드와 같은 AI가 각각의 분리된 풀 리퀘스트를 검토할 때, 하나의 대형 풀 리퀘스트에 비해 훨씬 뛰어난 피드백을 제공하는 것이 실제 사례를 통해 강조됨
- 영상 마무리에서는 시청자에게 스택 디프 실제 구현 영상을 별도로 안내하며, 그래파이트와 협력해 본 과정을 거듭 언급함

---

## 세부 요약 - 주제별 정리

### AI 코드 리뷰는 이미 강력하지만, 최적화된 워크플로우가 필요함

- AI를 통한 코드 리뷰가 매우 강력하다고 제작자는 언급함
- 본인의 작업 검증(validation)에 있어 필수적인 요소로 보고 있음
- 그러나 AI 코드 리뷰의 효과를 극대화하는 특정 워크플로우가 있다는 점을 강조
- 그 방법이 바로 '스택 디프(Stacked Diffs)' 방식임

### 전통적인 풀 리퀘스트 방식은 작업 대기와 비효율이 불가피함

- 기존 풀 리퀘스트 흐름에서는 코드 변경 후 승인(리뷰)을 기다려야 함
- 승인 절차가 끝나야 다음 변경 작업을 시작할 수 있어 이어지는 반복과 대기가 필요
- 이런 방식에서는 전체 기능 완성을 위한 반복이 비효율적으로 느껴질 수 있음

### 스택 디프 방식은 작은 변경의 누적으로 효율적 작업이 가능함

- 스택 디프는 작은 단위의 변경들을 연속적으로 쌓는 방법임
- 각각의 변경(diff)들이 이전 변경 위에서 추가되며 전체 기능이나 작업을 구성해감
- 각 변경이 서로 연결되어 있으므로 한 번에 큰 코드를 다루는 대신, 부분적이면서 세밀한 작업이 가능
- 승인(리뷰) 대기 없이 곧바로 다음 변경을 쌓고 이어갈 수 있는 장점 있음

### 스택 디프 방식은 AI 코드리뷰와 결합될 때 장점이 극대화됨

- 각 변경 단위(diff)에 AI 코드 리뷰를 집중해서 적용할 수 있음
- 쪼개진 작은 변경이기에 AI가 핵심 변화에 대해 더 정확히 피드백 가능
- 이렇게 함으로써 기존의 커다란 리뷰에 비해 훨씬 명확하고 치밀한 코드 개선이 진행됨

### 그래파이트(Graphite) 플랫폼이 스택 디프 워크플로우를 손쉽게 제공함

- 그래파이트(Graphite)가 스택 디프 작업에 최적화된 플랫폼임을 설명
- GitHub CLI와 유사하지만 스택 디프 관리에 특화된 명령행 도구 제공
- 대시보드에서 한눈에 전체 스택 디프 현황과 개별 PR을 관리 가능
- 내장된 AI 코드 어시스턴트가 각 풀 리퀘스트의 리뷰를 지원

### 그래파이트 시작 시 제공되는 안내 데모가 직관적 실행을 도와줌

- 회원가입 후 바로 시작되는 데모가 새로운 사용자를 안내
- 첫 스택 디프 생성부터, 그 위에 추가 변경(PR)을 쌓는 과정까지 단계적으로 보여줌
- Git이나 GitHub CLI를 익힌 개발자에게도 익숙한 명령어 체계로 작동
- 각각의 변경을 명확하게 구분하여 구조적으로 관리 가능함

### 세 개의 누적된 풀 리퀘스트를 예시로 단계별 과정을 시연함

- 첫 변경을 만들고, 풀 리퀘스트(PR)로 등록함
- 그 이후에 두 번째, 세 번째 PR을 각각 첫 번째와 그다음 PR 위에 쌓듯이 진행함(총 3개의 누적 PR)
- 커맨드라인에서 쌓여가는 디프 구조를 실시간으로 시현
- 전체 변경 사항이 어떻게 스택 형태로 구조화되어 가는지 구체적으로 보여줌

### 그래파이트 대시보드에서 관리, 리뷰, 병합까지 모두 진행 가능함

- 그래파이트 대시보드에서 각 풀 리퀘스트를 효율적으로 관리할 수 있음
- 그래파이트 에이전트(assistant)를 활용해 AI 기반 코드를 리뷰할 수 있음
- 별도의 GitHub 레포지토리에 직접 접속하지 않아도 대시보드 내에서 모든 작업 처리 가능
- 머지(Merge)도 대시보드에서 일괄적으로 처리 가능

### 각 변경은 별도의 피처 브랜치에서 관리되고, 메인 브랜치 반영 전까지 순차 병합함

- 각각의 변화(diff)는 개별적인 피처 브랜치에서 이루어짐
- 변경간 내부 병합을 통해 전체 스택(누적변경) 구조를 완성
- 최종적으로 모든 작업이 메인(Main) 브랜치에 머지되기 전까지 단계적으로 진행됨
- 실제 Git의 강점을 아주 똑똑하게 활용하는 방식임을 강조함

### 작은 단위별 AI 리뷰는 대형 풀 리퀘스트 리뷰 대비 압도적으로 효과적임

- 각 소규모 변경점에 AI 코드리뷰(AI reviewer)가 집중 가능
- Claude 코드 등 AI가 각 풀 리퀘스트별로 별도 분석 제공
- 큰 덩어리로 리뷰할 때보다 체계적이고 세밀한 품질 개선이 가능함을 실제 사례로 확인
- 대형 PR 한 번 검토하는 것과 비교했을 때 결과 차이가 "매우 놀랍다(insane)"고 강조

### 실제 구현 영상 및 그래파이트와의 협력을 별도로 안내함

- 영상 말미에 별도의 스택 디프 구현법 영상 링크를 설명란에 안내한다고 언급
- 본 안내 영상은 그래파이트 측과의 협력을 통해 진행되었음을 알림

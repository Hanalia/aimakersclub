---
author: AI Makers Club
pubDatetime: 2025-09-25T08:19:35.815Z
title: "The True Power of AI Coding - Build Your OWN Workflows (Full Guide)"
slug: mHBk8Z7Exag
featured: true
draft: false
tags:
  - AI
  - YouTube 요약
  - 자동 업로드
description: "AI 코딩 어시스턴트를 사용할 때, 단순 프롬프트 입력만으로는 한계가 있으므로, 진짜 힘은 자신만의 시스템과 워크플로우를 구축하는 데 있음 PRP 프레임워크, BMAD, GitHu"
---

<div style="text-align: center;">
  <img src="https://img.youtube.com/vi/mHBk8Z7Exag/maxresdefault.jpg" alt="YouTube Thumbnail" style="width: 100%; max-width: 640px; height: auto; border-radius: 0.5rem; box-shadow: 0 2px 8px rgba(0,0,0,0.1);" loading="lazy" />
</div>

**영상 링크:** [The True Power of AI Coding - Build Your OWN Workflows (Full Guide)](https://www.youtube.com/watch?v=mHBk8Z7Exag)  
**채널명:** Cole Medin

## *AI 코딩의 진정한 힘 - 나만의 워크플로우 구축법 (완벽 가이드)* 핵심 요약

- AI 코딩 어시스턴트를 사용할 때, 단순 프롬프트 입력만으로는 한계가 있으므로, 진짜 힘은 자신만의 시스템과 워크플로우를 구축하는 데 있음
- PRP 프레임워크, BMAD, GitHub Spec Kit 등 다양한 전략이 존재하지만, 실제로 중요한 것은 이 전략들의 철학과 구조를 이해하고 자신에게 맞게 커스터마이즈하는 것
- 영상에서는 기존 프레임워크를 넘어서 자신의 워크플로를 만들어가는 3단계 모델(기획→구현→검증)을 세부적으로 소개
- 기획 단계는 'Vibe Planning'(자유 탐색 단계) → 명확한 요구사항(MD 작성) → AI가 작업할 수 있는 컨텍스트 준비의 순서로 진행됨
- 구체적 구현을 위해 슬래시 커맨드(/command), 서브에이전트(sub agent), 글로벌룰 등 도구와 구조적 접근을 추천
- 실제 예시로 Obsidian(무료/로컬 지식 관리 플랫폼)에 AI 에이전트와 코파일럿 챗 및 Docker를 연동하여 워크플로우를 보여줌
- 코드 구현 시에는 태스크 관리의 세분화(작은 단위의 할 일로 분리)와 단계별 코딩, 검증을 구조화하여 실수를 줄이고 품질을 향상
- Archon, Code Rabbit(코드리뷰 자동화), 클라우드 코드 등 다양한 오픈소스 툴 및 플러그인을 활용, 자동화와 검증을 증명함
- 플래닝·검증 단계에는 서브에이전트를 적극 활용하지만, 구현(코딩) 단계에서는 서브에이전트 간 메모리/컨텍스트 분산 문제 때문에 사용하지 않음
- 영상 전반에 걸쳐 각 단계별 명확한 마크다운 문서, 태스크 리스트, 성공 기준 등 '구조화된 문서화'를 매우 강조
- 자신만의 규칙/워크플로우/정신 모델(기획→구현→검증)을 구축하면, 어떤 AI 코딩 전략/프레임워크도 목적에 맞게 유연하게 조합 가능하다는 점을 결론으로 제시

---

## 세부 요약 - 주제별 정리

### 기존 AI 코딩 전략(프레임워크)은 이해와 변형이 핵심임을 강조함

- AI 코딩 전략(PRP, BMAD, GitHub Spec Kit 등)은 수없이 많아 혼란스럽기 쉽다고 언급
- 이 다양한 프레임워크들의 구조와 철학을 이해하면, 자신의 목적에 맞게 조합하거나 직접 워크플로우를 만들 수 있음
- 기존 프레임워크(특히 PRP와 BMAD)를 단순히 따라하는 게 아니라, 자신만의 방식으로 발전시키는 것이 진정한 활용법임을 강조

### 3단계 워크플로우(기획→구현→검증) 구조가 효과적임을 밝힘

- 영상 전체는 ‘기획(Planning)→구현(Implementing)→검증(Validation)’ 3단계에 집중
- 이 세 단계를 중심으로 사용자가 AI 코딩 어시스턴트를 능동적으로 활용할 수 있게 됨
- 각 단계별 역할과 필요한 도구, 전략, 문서화 방식을 구체적으로 안내

### 기획(Planning) 단계는 자유로운 탐색과 점진적 구조화가 핵심임

- 첫 단계는 'Vibe Planning'이라 부르며, 자유로운 아이디어 탐색과 구조적 준비 단계임
- 새 프로젝트일 경우, 온라인 자료/기존 프로젝트 예시에 대한 리서치와 AI와의 대화로 아이디어를 정제함
- 기존 프로젝트라면, 코드베이스 분석 및 기존 파일의 통합 포인트를 탐색
- 모든 탐색 과정은 코딩 어시스턴트와의 문맥 공유(컨텍스트 공유)로 이뤄짐

### 최초 요구사항은 구체적 마크다운(MD) 문서화가 중요함

- 'Initial MD'(최초 마크다운)는 프로젝트/기능의 핵심 요구사항, 예시, 참고 자료를 포괄한 초기 문서
- 신규 프로젝트는 간결한 MVP와 연관 문서, 예제까지 포함함
- 기존 프로젝트는 구체적 파일 수정 포인트, 아키텍처 참고 파일, 통합 지점을 중점적으로 문서화
- 이 MD는 이후 보다 구조화된 프롬프트/플랜 생성의 기반이 됨

### 요구사항을 AI가 이해할 수 있는 컨텍스트로 변환하는 과정이 필요함

- RAG(외부 문서 참조), Memory(대화 내역), Task Management, Prompt Engineering 등 컨텍스트 엔지니어링 요소 소개
- Initial MD를 바탕으로 구체적인 작업 목표, 리소스, 성공 조건이 포함된 2차 마크다운(계획)을 작성
- 이 구조는 PRP 프레임워크의 핵심을 설명하며, 자주 쓰이는 다이어그램(re-created in Excaladraw)도 직접 제작
- Archon, Github Spec Kit, 클라우드 코드 등 도구를 예시로 들어 구체적 실행을 보여줌

### 슬래시 커맨드(/commands)와 서브에이전트(sub agents)가 자동화와 관리에 유용함을 시연함

- 'Primer'라는 슬래시 커맨드로 AI 어시스턴트가 새 대화에서도 핵심 파일 맥락을 빠르게 습득하도록 함
- 각 플래닝, 구현, 검증 단계 별로 전용 커맨드(/commands)와 필요한 sub agent를 구성할 수 있음
- 예: 'create plan.md' 명령은 요구사항 문서(Initial MD) 기반 계획서 생성, sub agent가 리서치를 분담
- 서브에이전트는 개별 컨텍스트로 깊이 있는 리서치·검증을 수행, 본 대화 맥락은 간결하게 유지

### Archon, Obsidian 등 실제 도구 연동 예제로 실전적 구조를 보여줌

- Obsidian(무료 오픈소스 지식관리 플랫폼)과 개인 AI agent, Docker 환경을 연동하는 과정을 실제 예로 시연
- co-pilot chat을 우측에서 활용, Obsidian 내 특정 파일 참조·질문도 가능
- Archon으로 태스크 및 프로젝트 관리, 코드베이스 분석/통합 자동화
- 각 단계별로 커맨드/예시/출력 결과 화면을 시연해 구체적 활용법 제시

### 세부 구현 단계에서는 태스크 분할, 집중적 관리로 오류와 환각(헛소리) 방지함

- 각 구현 단계는 Archon 등 태스크 관리 도구와 연결되어 작은 단위로 분할
- 한번에 많은 작업을 시키면 환각(hallucination) 위험이 늘어나므로 태스크별 집중 처리가 필수
- ‘execute plan’ 커맨드로 계획문서를 불러와 태스크를 분리 수행
- 다양한 태스크 관리 도구와 연동(AI별 내부 관리 시스템, 마크다운, 클라우드 태스크마스터 등 자유 사용)

### 검증(Validation) 단계에서는 다시 서브에이전트 및 자동 코드 리뷰를 적극 활용함

- 구현 완료 후에는 서브에이전트(Validator)를 호출해 다양한 테스트·코드 검증을 실행
- Code Rabbit(코드 리뷰 에이전트)와 Archon 자동화로 Pull Request마다 자동 리뷰, 변경사항, 추천 리뷰어, 시퀀스 다이어그램, 구조적 코드 리뷰 결과 제공
- Code Rabbit은 오픈소스(Archon 등)에는 무료, CLI 도구와 IDE 연동 기능도 있음
- 수동 코드리뷰, 매뉴얼 테스트 병행 권장

### 서브에이전트는 플래닝·검증에는 적합하지만 ‘구현 단계’에서는 피해야 함을 명확히 구분함

- 플래닝/검증은 서브에이전트별 컨텍스트 분리에 이점(깊은 리서치, 독립 검증 등)이 있으나,
- 구현(코딩)단계에서 서브에이전트를 사용하면 메모리 불일치/중복 변경/혼란 야기됨
- 따라서 코드 작성은 반드시 메인 대화창(코딩 어시스턴트 본체)에서 집중 수행
- 각 서브에이전트에는 높은 전문성과 특정 목표(예: 검증만 담당)의 프롬프트 제공이 효과적임

### 전체 구조는 마크다운, 태스크 리스트, 성공 기준 등 ‘구조화된 문서화’가 핵심임을 강조함

- 플래닝·구현·검증 단계마다 명확한 마크다운 문서, 태스크, 성공 기준, 참조 문서 등 기록 유지
- 글로벌 룰(global rules)은 플래닝 단계에서 프로젝트/기능/버그수정 등 전체 작업에 적용할 규칙(예: 주요 가이드라인)을 정의
- 구조화된 문서와 워크플로우를 직접 설계해, 반복적이고 확장 가능한 AI 코딩 시스템을 누구나 만들 수 있음을 실증
  
### 자신만의 철학·정신 모델과 도구 조합으로 다양한 AI 코딩 전략을 통합 적용할 수 있음을 결론으로 제시함

- 기획→구현→검증 3단계 모델을 중심으로, 자신만의 규칙/슬래시커맨드/에이전트 조합 구축을 추천
- PRP, Github Spec Kit, BMAD 등 전략은 자신만의 워크플로우에 맞게 자유롭게 조합·응용 가능
- 영상에서 설계한 구조는 특정 프로젝트에 국한되지 않고 다양한 AI 코딩 프로젝트에 재활용 가능함을 마지막 시연(Obsidian 연동)으로 증명

---
author: AI Makers Club
pubDatetime: 2025-11-25T23:45:34.202Z
title: "Hacking Subagents Into Codex CLI - Brian John, Betterup"
slug: 5eJqXtevlXg
featured: true
draft: false
tags:
  - AI
  - YouTube 요약
  - 자동 업로드
description: "Brian John(베러업 소속 수석 풀스택 엔지니어)이 Codeex CLI에서 \"서브 에이전트(Subagent)\"를 활용하는 실질적 해킹 및 구현 방법을 공유함 기존 Claude"
---

<div style="text-align: center;">
  <img src="https://img.youtube.com/vi/5eJqXtevlXg/maxresdefault.jpg" alt="YouTube Thumbnail" style="width: 100%; max-width: 640px; height: auto; border-radius: 0.5rem; box-shadow: 0 2px 8px rgba(0,0,0,0.1);" loading="lazy" />
</div>

**영상 링크:** [Hacking Subagents Into Codex CLI — Brian John, Betterup](https://www.youtube.com/watch?v=5eJqXtevlXg)  
**채널명:** AI Engineer

## *Codeex CLI에서 서브 에이전트 활용 해킹 방법* 핵심 요약

- Brian John(베러업 소속 수석 풀스택 엔지니어)이 Codeex CLI에서 "서브 에이전트(Subagent)"를 활용하는 실질적 해킹 및 구현 방법을 공유함
- 기존 Claude Code 등 LLM 도구의 장점을 유지하면서, 특정 툴이나 모델 패밀리에 종속되지 않고 Codeex CLI에서도 동일한 워크플로우를 사용하려는 취지 강조
- 서브 에이전트는 맥락 관리(Context Management)에 탁월하여, 메인 에이전트의 컨텍스트 윈도우를 넘치게 하지 않으면서 각 서브 에이전트가 별도로 문제를 해결한 결과만 반환 가능
- Dex Hory의 AI 에이전트 워크플로우 및 대규모 코드베이스 작업 효율성 사례를 참조, 실제로 효과적임을 강조함
- 서브 에이전트 실행 과정: 부모 Codeex 세션이 래퍼 스크립트를 통해 프롬프트와 실행 정보를 재구성 후, 자식 Codeex(서브 에이전트)를 별도로 실행하여 결과를 파일로 저장, 래퍼가 해당 결과를 표준 출력으로 반환하도록 설계
- Codeex의 샌드박스(Sandbox) 권한 체계와 보안 장치로 인해 정상적인 실행을 위해서는 최소한의 권한 조합 설정이 핵심 난관임을 언급
- 권한 설정: 부모 프로세스에는 sandbox workspace 권한이 필요하며, 자식 프로세스에서는 OpenAI 인증 정보 접근 제한 등으로 인한 추가 제약 및 rollout recorder 비활성화 필요
- 메타(Meta)의 "에이전트 보안 Rule of Two"를 예로 들어, 에이전트가 민감 시스템에 접근할 경우 위험도가 낮거나 중간 수준이라도 보안 리스크는 잔존함을 강조
- 실질적 구현 예시로 오픈소스 저장소를 소개, 각 서브 에이전트의 정의 방식, 래퍼 스크립트 구조, 실행 로직 등을 코드 레벨에서 상세히 시연
- Codeex에서는 서브 에이전트 호출시 비동기가 아닌 순차 실행만 가능하며, Claude Code 대비 상대적으로 느린 점이 있지만 이는 의도된 설계임을 피력
- 실제 데모를 통해 에이전트 동작 및 코드 구조, 타임아웃(최대 10~20분 소요 가능) 등 실무적 노하우까지 구체적으로 공유함
- 활용 코드 저장소 및 문의 방법(이메일·X DM 포함) 소개하며 발표를 마무리

---

## 세부 요약 - 주제별 정리

### 발표자는 베러업의 AI 활용·R&D 지원을 담당하는 수석 엔지니어임을 설명함

- Brian John은 베러업(BetterUp)의 Principal Fullstack Engineer로, R&D 팀원들의 생산성 및 결과 향상을 위한 AI 활용·도구 개발을 전담함
- 베러업은 설립 초기부터 AI를 적극적으로 도입해왔으며, Brian은 8년 이상 근무 중임(본인 경력 중 최장기)
- 회사 미션은 "전 세계 사람들이 더 명확한 목표와 열정으로 삶을 살도록 지원"하는 것임
- AI, 특히 LLM 관련 혁신적인 작업에 관심이 있다면 언제든 연락해달라고 안내 (연락처는 영상 마지막 슬라이드 참고)

### 다양한 LLM 도구 및 모델로 확장 가능한 워크플로우를 지향함을 강조함

- 발표자는 Claude Code를 오랫동안 메인 도구(데일리 드라이버)로 사용해왔고, 그 강력한 기능 및 모델품질, 서브 에이전트 활용성이 매우 커서 만족해옴
- LLM 도구 종속성(특정 회사/툴 혹은 모델 패밀리)에 묶이고 싶지 않다는 점을 역설
- 특히 Codeex CLI의 최신 모델 성능이 뛰어나다는 점에 주목, 유연한 활용을 위해 동일한 "서브 에이전트" 중심의 워크플로우를 Codeex에도 이식하고 싶었다고 설명

### 서브 에이전트의 개념과 맥락 관리 용도를 상세히 설명함

- 서브 에이전트란, 메인 에이전트로부터 특정 하위 문제를 할당받아 독립적으로 처리하는 또다른 인스턴스(하위 에이전트)임
- 서브 에이전트는 자체 토큰을 사용해 작업을 진행하고, 결과만 메인 에이전트에 반환
- 이 방식 덕분에 대용량 컨텍스트 쏟아붓기 문제(메인 세션의 컨텍스트 윈도우 초과 등)를 피할 수 있음
- 실제 대규모 코드베이스 작업, 복잡한 워크플로우 등에서 반복적으로 겪는 문제를 효과적으로 해결함
- Dex Hory의 AI Workflow 관련 발표에서 제안된 방식 및 사례를 참조, 특히 대규모 코드에서 탁월함을 시사

### Codeex CLI에서 서브 에이전트 동작 구조와 설계를 구체적으로 설명함

- 서브 에이전트는 결국 또 하나의 메인 에이전트 인스턴스이므로 구조도 간단하게 설계 가능
- 구현의 흐름:
    - 부모 Codeex 세션이 프롬프트, 실행 정보 등을 준비하는 래퍼 스크립트 실행
    - 래퍼 스크립트는 내부적으로 어떤 에이전트를 띄울지 결정, 프롬프트 조립, 실행 관리 등 전체 흐름 담당
    - 코드상 "codeex exec"를 통해 자식 Codeex 프로세스(서브 에이전트)를 별도로 실행
    - 서브 에이전트가 결과를 파일로 저장하면, 래퍼 스크립트가 이 파일을 읽어 표준 출력으로 반환하여 부모 세션에 전달
    - 전반적으로 "간단 명료한" 흐름으로 설계했다고 설명
- 하지만 실제 구현시 Codeex의 샌드박스와 권한 통제로 인해 다수 실행 오류를 경험, 난이도가 높았다고 고백

### Codeex 샌드박스 권한 체계와 최소 권한 조합에 대한 시행착오 및 해결법을 공유함

- Codeex 샌드박스는 기본적으로 함부로 하위 프로세스 실행 또는 민감 정보 접근을 막기 때문에, 권한 조합 설정이 핵심 과제임
- 일반적으로 부모 프로세스에는 최소 "sandbox workspace" 권한이 필요 (별도의 "dangerously skip permissions" 사용 가능하지만, 권장하지 않음)
- 자식 프로세스(서브 에이전트)는 더욱 엄격함
    - OpenAI 인증 정보가 집(home) 디렉터리 외부로 공유되지 않아 접근 제한
    - workspace 내 파일(결과 저장 파일 등)에 쓸 수 있도록 sandbox workspace write 권한 필수
    - rollout recorder(로그 기록 시스템) 비활성화 필요. 부모 샌드박스가 workspace 외부 파일시스템 접근을 막기 때문
- 결국 "최소 권한 조합"을 찾는 시행착오가 가장 어려운 과정이었음

### 에이전트 시스템의 보안 리스크를 메타의 연구를 근거로 점검하며 실무 조언을 공유함

- 보안 관련 참고자료로 Meta(메타)에서 발표한 "Agents Rule of Two" 논문을 언급
    - 1) 불신입력 처리, 2) 민감/비공개 대상 접근, 3) 상태 변화·외부 통신 가능성 등 총 3가지 축에서 에이전트 보안 리스크를 식별
- 발표자의 시스템에서는
    - 불신입력은 처리하지 않음
    - 민감 시스템/프라이빗 데이터(사내 코드베이스 등) 접근은 있음
    - 상태 변화·외부 통신 가능(상태 변화는 시스템 구조에 따라 다르며, 외부 통신은 OpenAI API엔드포인트 한정)
- 자사 시나리오 상 낮은 위험군이지만, "낮은 리스크 ≠ 무(無)리스크"임을 강조
    - 구현 환경 및 요구에 따라 각자 신중한 판단 필요

### 실행 전략 및 실제 agents, wrapper 스크립트, 에이전트 실행 구조 등 코드를 코드레벨로 상세히 소개함

- Codeex가 서브 에이전트 활용 시 각 에이전트 실행 방식 설정 필요(agents.md 사용)
    - "어떤 경우"에(예: 사용자가 요청/상황 판단 시) "어떤 서브 에이전트"를 호출할지 정책 기술
- 오픈소스 개념증명 저장소(PoC)에서 두 개의 Toy Agent(단어 카운터, 파일 라이터)를 정의.
    - 각 에이전트 정의: 이름, reasoning effort(작업 난이도: light, medium, high), 프롬프트 등 명시
- wrapper script 구조(72줄 내외): 입력값을 받아 agent executor 클래스 호출, 출력 결과를 표준 출력으로 반환
- agent executor 클래스: 권한 부여, reasoning effort 전달, rollout recorder 비활성화 등 실행에 필요한 부수 처리를 자동화
- agents.md에서 subagent 호출 시 "명령어 인자"로 agent name, 쿼리 등을 파일에 쓰고 동일 명령어만 실행하도록 설계
    - 명령어 인자가 매번 달라지면 매번 권한 승인해야 하므로 불편함. (동일 명령은 한 번만 승인받으면 됨)
    - "dangerously skip permissions"를 사용하면 이 불편이 사라지지만 이는 비권장

### 코드 실행속도, 직렬(순차)처리 한계 등 Codeex CLI의 설계적 특성을 있는 그대로 공유함

- Codeex는 서브 에이전트 직렬(순차) 실행만 지원(비동기 병렬처리 불가)
- Claude Code 대비 Codeex의 전체 속도 자체가 상대적으로 느림
- 이는 Codeex가 "핸즈오프(자동, 무인, 장기실행)"용으로 설계된 반면, Claude Code는 "인터랙티브(즉석 상호작용)" 진행에 초점을 둔 결과라 해석
- 발표자 본인 workflow에서는 Codeex가 더 느려도 충분히 문제가 안 됨을 언급

### 실제 데모를 통해 서브 에이전트 호출·결과 반환·타임아웃 설정 등 실무적 운영 방식까지 상세히 제시함

- 실습 예시: 쿼리 수행 요청 시 워크카운터·파일라이터 서브에이전트를 순차 호출
    - 호출 과정: agent명·쿼리 파일 작성→명령 실행→최초 승인 시 "다시 묻지 않기" 선택 필요(동일 명령 반복 요청 방지)
    - 실행 결과는 표준 출력으로 반환
- 타임아웃 설정(예시: 600초=10분)
    - 대규모 코드베이스 작업 등 장기 실행 필요 시 20분까지 소요될 수 있어 타임아웃 값을 길게 잡을 수 있음
    - 본 데모 예시는 40초 만에 완료
    - 실제 파일 생성 여부 등 결과 확인 절차 소개
- 전체 코드 깊이는 많지 않으며, 직관적으로 동작하는 구조임을 반복 강조

### 코드 저장소 정보, BetterUp·연락처 안내를 끝으로 실무 중심 발표를 마무리함

- PoC 오픈소스 저장소 URL(마지막 슬라이드) 안내
- BetterUp 공식 웹사이트(betterup.com) 및 개인 연락처(이메일, X DM) 공유
- X(트위터)에는 포스팅은 안하지만 DM은 열려있다고 언급
- LLM, 에이전트, AI 인프라에 관심있는 개발자의 연락을 환영하며 발표 종료

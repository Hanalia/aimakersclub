---
author: AI Makers Club
pubDatetime: 2025-07-05T08:18:49.375Z
title: "Claude Code & the evolution of agentic coding -  Boris Cherny"
slug: Lue8K2jqfKk
featured: true
draft: false
tags:
  - AI
  - YouTube 요약
  - 자동 업로드
description: "본 영상은 앤트로픽(Anthropic)의 Boris Cherny가 직접 개발한 \"Claude Code\"와 AI 코딩 도구의 진화 및 UX(사용자 경험)의 변화 과정을 기술적으로 상"
---

<div style="text-align: center;">
  <img src="https://img.youtube.com/vi/Lue8K2jqfKk/maxresdefault.jpg" alt="YouTube Thumbnail" style="width: 100%; max-width: 640px; height: auto; border-radius: 0.5rem; box-shadow: 0 2px 8px rgba(0,0,0,0.1);" loading="lazy" />
</div>

**영상 링크:** [Claude Code & the evolution of agentic coding -  Boris Cherny](https://www.youtube.com/watch?v=Lue8K2jqfKk)  
**채널명:** AI Engineer

## *Claude Code와 에이전틱 코딩의 진화* 핵심 요약

- 본 영상은 앤트로픽(Anthropic)의 Boris Cherny가 직접 개발한 "Claude Code"와 AI 코딩 도구의 진화 및 UX(사용자 경험)의 변화 과정을 기술적으로 상세하게 설명함
- Claude Code는 모델(LLM)의 비약적인 발전 속도에 맞는 제품의 UX와 형태에 대해 "의견을 두지 않는 최소한의 제품" 전략을 택함
- 코딩 도구와 프로그래밍 언어, 그리고 IDE 및 코딩 환경의 변천사가 1950년대 펀치카드~2020년대 AI 코딩 에이전트까지 구체적인 사례(Ed, Vim, Smalltalk 80, Visual Basic, Eclipse, Copilot, Cursor 등)와 함께 정리됨
- Claude Code는 VS Code, iTerm2, WSL, SSH, Tmux 등 거의 모든 터미널, IDE 환경에서 사용 가능하며, GitHub 통합 및 SDK로 확장된 활용도 제공
- 제품 디자인 원칙은 "최대한 단순하고 범용적이며, 유저의 워크플로우에 자연스럽게 스며드는 것"임. 이는 모델의 기능이 지속적으로 비약적으로 향상되는 점에 기인
- 코드 기반 Q&A, 코드 기반 툴 사용 학습, 플랜 기반 워크플로우, 확장된 컨텍스트 제공, TDD 등 실제적이고 구체적인 Claude Code 사용 팁을 제시
- Claude Code의 주목할 만한 기능으로는 ‘플랜 모드(Plan Mode)’, ‘쿼드 메모리(Quad Memory, quadm)’, 슬래시 커맨드 기반 워크플로우 등이 있음
- 제품의 사용성과 진화를 위해 실제 유저 피드백 및 반복적인 실험과 개선 과정을 매우 중시함을 강조
- GitHub, 터미널, SDK 등 다양한 통합 옵션을 통해 엔지니어가 자신만의 워크플로우를 쉽게 실현할 수 있게 설계
- 강연 후반 소규모 Q&A에서 멀티-인스턴스 운용, 병렬 작업 등 파워 유저 중심의 실사용 노하우가 공유됨

## 세부 요약 - 주제별 정리

### 프로그래밍 언어와 환경은 하드웨어 기반에서 고급 소프트웨어 추상화로 꾸준히 진화해 왔음

- 1930~50년대 초창기 프로그래밍은 스위치보드, 물리적인 펀치카드 등 하드웨어 중심으로 이뤄졌음
- Boris의 할아버지가 1970년대 소련에서 최초의 프로그래머 중 한 명이었으며, 커다란 펀치카드 묶음을 집에 가져오곤 했다는 개인적 일화를 소개
- 1950년대 후반부터 어셈블리 언어(Assembly), COBOL, C++, 하스켈, 자바, 파이썬, 타입스크립트 등 고급 프로그래밍 언어로 진화
- 최신 언어의 추상화는 점점 상향 평준화되어, TypeScript, Rust, Swift, Go 등 여러 최신 언어들이 점점 유사한 사용성을 보임

### 프로그래밍 언어의 UX와 IDE 혁신은 AI 출현 전까지 꾸준히 계단식 발전을 거듭함

- 1950년대에는 타자기를 이용한 펀치카드 프로그래밍, 이후 ‘Ed’가 등장하며 최초의 텍스트 에디터 시대 진입(케네스 톰슨이 개발)
- Vim, Emacs 등 편집기는 1980년대에 혁신적 발전을 이룸
- Smalltalk 80(1980)은 최초의 그래픽 프로그래밍 인터페이스이며, 라이브리로드 기능을 제공하여 UI 혁신을 선도함
- 1991년 Visual Basic은 그래픽 패러다임을 주류로 도입하며 본격적인 GUI 프로그래밍 환경 확산
- Eclipse IDE는 심볼 인덱싱 기반 자동완성(typeahead), 서드파티 플러그인 생태계 등 주요 혁신을 도입
- 최근에는 Github Copilot, Cursor 등 AI 기반 IDE 및 코딩 에이전트가 등장하며, 자연어→코드 변환이 가능해짐

### AI 모델의 코딩 능력 발전이 UX 진화를 폭발적으로 가속화하고 있음

- AI 모델(특히 LLM)은 코딩 능력이 기하급수적으로 향상되고, 이에 맞는 제품 개발이 뒤따라가기 벅찬 상황
- 코딩 도구 UX 측면에서도 발전 속도가 가팔라지는 중이며, AI 기반 플러그인/에이전트가 빠르게 확산 중
- "가장 범용적인 모델이 항상 이김(More general model always wins)"이라는 원리 강조
- 제품군 또한 범용성, 단순함을 우선시해야 변화하는 모델 역량에 맞게 빠르게 적응할 수 있음

### Claude Code는 터미널 기반의 최소한 UX와 폭넓은 통합성을 제공하기 위해 설계됨

- Claude Code는 iTerm2, WSL, SSH, Tmux, VS Code 터미널, Cursor 터미널 등 거의 모든 터미널 환경 지원
- IDE에서는 디프(diff) 표시, 진단 정보(ingest diagnostics) 활용 등 추가적 기능을 제공
- GitHub 플러그인: 한 줄 명령어만으로 레포와 연동, 개인 컴퓨트에서 동작하며 데이터가 외부로 노출되지 않음(프라이버시 중시)
- SDK를 통해 터미널, IDE, GitHub 등과 별개로 개발자가 원하는 방식으로 클라우드 코드와 통합 가능
- 예시로 GCP 로그를 Claude Code에 파이프라인해 결과를 jq로 후처리하는 Unix 유틸리티적 활용 사례 언급

### 제품 기능 설계에서 "의견 없음(unopinionated)"과 범용적 최소 구현(MVP)을 강조함

- Anthropic은 "어떤 제품이 최적인지 아직 모르기 때문에" Claude Code를 가능한 한 단순하고 일반적으로 만듦
- 사용자 피드백과 다양한 워크플로우 실험을 통해 자연스럽게 진화하는 형태를 지향함
- 기존 IDE처럼 확정적 플러그인 시스템 설계가 아닌, 사용자가 자유롭게 도구를 결합·활용할 수 있도록 개방성 확보

### 코드기반 질문/답변, 도구교육, 계획생성, TDD 등 다양한 워크플로우로 Claude Code를 활발히 활용할 수 있음

- 1) 코드 기반 Q&A: 신규 개발자 온보딩 시 Claude Code로 문서/코드 질문처리 시간을 2~3주→2일로 대폭 단축
- 2) 도구 사용법 학습: Bash, GCP 등 사용 환경에 내장된 CLI 툴을 Claude Code에게 명령어 도움말을 제공하여 능동적 학습 가능
- 플러그인/확장 만들기 필요 없이 자연스럽게 모든 CLI/개발도구 통합
- 3) 계획(Plan) 워크플로우: Claude Code에게 우선 탐색-플랜을 요청 후 승인받고 실행, "생각하기(extended thinking)"도 컨텍스트 확보 후 요청 시 효과적
- 4) TDD(Test Driven Development): 먼저 테스트코드를 생성하고, 이를 바탕으로 실제 코드를 작성, 모델 기반 TDD가 효과적으로 적용됨
- 5) 타겟 기반 반복(iteration): 단위테스트/통합테스트/스크린샷 등 명확한 산출물을 두고 코드를 다듬으면 결과가 비약적으로 향상됨

### 플랜 모드, 쿼드 메모리 등 Claude Code의 주요 기능이 유저 주도적 워크플로우를 지원함

- 새롭게 출시된 Plan Mode: Shift+Tab으로 진입, 실행 전 먼저 전체 플랜을 제시해 승인 후 실행 가능
- Quadm(쿼드 메모리): 레포(root)의 quadd 파일, 서브폴더, 홈폴더 등에 주요 정보를 배치해 자체적으로 참조 가능
- 슬래시 커맨드 명령어, 마크다운 파일 기반 반복워크플로우 구성
- # 기호로 사용자가 정보를 암기시켜 쿼드 메모리에 저장 가능

### 기존 IDE와 달리 "모델 기억(Memory)", "도구 조합" 등 AI 에이전트 특유의 신개념 UX를 적극 원용함

- 본격적으로 "코딩 모델의 메모리(memory)" 활용 개념은 과거 IDE에 없었던 신선함
- 쿼드 메모리/명령/플랜 등 사용자 경험을 실험적으로 설계하고, 반복적으로 개선할 방침
- 실제 필드 유저의 사용 패턴과 피드백을 최우선 고려하여 실질적인 유용성에 집중

### 다양한 통합 환경 및 SDK, 오픈형 활용성을 통해 개발자별 맞춤 워크플로우를 실현할 수 있음

- CLI, IDE, GitHub, 프로그램적 사용(SDK) 등 원하는 방식으로 Claude Code를 구성·확장 가능
- 예) GCP 로그 자동 triage, 커스텀 UI, 자체 파이프라인 구축 등 광범위한 활용 사례가 등장
- "Unix 유틸리티처럼 모델을 쓰는 시대"로서 새로운 사용법이 이제 막 개척 중임을 강조

### Q&A에서 실무 엔지니어를 위한 "멀티 인스턴스" 병렬 활용 등 구체적인 tips가 제시됨

- 대형 작업 병렬처리 시, 여러 터미널 탭에서 클로드를 독립 운영하거나, 여러 코드베이스/워크트리 동시 작업을 권장
- GitHub Actions 등 통해 병렬 작업도 수월
- 각 인스턴스 결과를 마크다운 파일에 쓰고, 별도 조율 없이 병렬 처리하는 실용적 접근 공유

### 제품 발전의 핵심은 빠른 유저 피드백과 반복 실험임을 끝까지 강조함

- 모든 기능과 워크플로우는 유저 피드백을 통해 더 정교해질 예정이며, 그 과정에서 단순함과 범용성을 재차 중시
- 모델의 비약적인 성장에 걸맞은, 미래 지향적이면서도 실질적으로 생산성을 높여주는 코딩 도구 설계가 최종 목표임
